> [참고자료 블로그](https://subicura.com/2019/05/19/kubernetes-basic-1.html)

> [공식문서 한글](https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/)

### 쿠버네티스란?
쿠버네티스는 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼이다. 쿠버네티스가 너무 길어서 흔히 케이츠(k8s) 또는 큐브(kube)라고 줄여서 부른다.

#### 특징
- 서비스메시(Istio, linkerd), CI(Tekton, Spinnaker), 컨테이너 서버리스(Knative), 머신러닝(kubeflow)이 모두 쿠버네티스 환경에서 돌아간다.
- 다양한 배포방식
  - Deployment: 새로운 버전의 애플리케이션을 다양한 전략으로 무중단 배포
  - StatefulSets: 실행 순서를 보장하고 호스트 이름과 볼륨을 일정하게 사용할 수 있어 순서나 데이터가 중요한 경우 사용
  - DaemonSet: 로그나 모니터링 등 모든 노드가 설치가 필요할 때 사용
  - Job, CronJob: 배치성 작업
- Ingress 설정
  - 다양한 웹 애플리케이션을 하나의 로드 밸런서로 서비스하기 위해 Ingress기능을 제공한다.
- Label & Namespace
  - 하나의 클러스터를 논리적으로 구분해서 사용할 수 있다.
  - 하나의 클러스터에 다양한 프레임워크와 애플리케이션을 설치하기 때문에 기본(`system`, `default`)외에 여러 개의 네임스페이스를 사용하는 것이 일반적이다.

#### 단점
- 복잡하고 초반에 개념을 이해하기 어렵다.
- YAML 설정 파일은 너무 많고 클러스터를 만드는 것도 쉽지 않다.

### 쿠버네티스 기본 개념
#### Desired State
쿠버네티스에서 가장 중요한 것은 **Desired state - 원하는 상태**라는 개념이다. 원하는 상태는 관리자가 바라는 환경을 의미한다. 구체적으로는 얼마나 많은 웹서버가 띄어 있으면 좋으지, 몇 번 포트로 서비스하기를 원하는 지를 의미한다.

쿠버네티스는 **현재 상태**를 모니터링하면서 관리자가 설정한 원하는 상태를 유지하려고 내부적으로 다양한 작업을 하는 단순한 로직을 가지고 있다.

이러한 개념 때문에 관리자가 서버를 배포할 때 직접적인 동작을 명령하지 않고 상태를 선언하는 방식을 사용한다. 예를 들어 "nginx 컨테이너를 실행해줘. 그리고 80 포트로 오픈해줘."는 현재 상태를 원하는 상태로 바꾸기 위한 명령이고 "80포트를 오픈한 nginx 컨테이너를 1개 유지해줘"는 원하는 상태를 선언한 것이다.

명령과 선언은 CLI 명령어에서도 드러난다.
```
docker run # 명령
kubectl create # 상태 생성
```

쿠버네티스의 핵심은 상태이며 쿠버네티스를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지를 알아야 한다.

#### Kubernetes Object
쿠버네티스는 상태를 관리하기 위한 대상을 오브젝트로 정의한다. 

##### Pod
쿠버네티스에서 배포할 수 있는 가장 작은 단위의 오브젝트이다. 한 개 이상의 컨테이너와 스토리지, 네트워크 속성을 가진다. Pod에 속한 컨테이너는 스토리지와 네트워크를 공유하고 서로 localhost로 접근할 수 있다. 컨테이너를 하나만 사용하는 경우도 반드시 Pod로 감싸서 관리한다.

##### ReplicaSet
Pod을 여러 개(한 개 이상) 복제하여 관리하는 오브젝트이다. Pod를 생성하고 개수를 유지하려면 반드시 ReplicaSet을 사용해야 한다.
ReplicaSet의 구성은 복제할 개수, 개수를 체크할 라벨 선택자, 생성할 Pod의 설정값 등을 가지고 있다.
직접적으로 ReplicaSet을 사용하기보다는 Deployment등 다른 오프젝트에 의해서 사용되는 경우가 많다.

##### Service
네트워크와 관련된 오브젝트이다. Pod을 외부 네트워크와 연결해주고 여러 개의 Pod을 바라보는 **내부 로드 밸런서를 생성**할 때도 사용한다. 내부 DNS에 서비스 이름을 도메인으로 등록하기 때문에 서비스 디스커버리 역할도 한다.

##### Volume
저장소와 관련된 오브젝트이다. 호스트 디렉토리를 그대로 사용할 수도 있고 EBS같은 스토리지를 동적으로 생성하여 사용할 수도 있다.

#### Object Spec - YAML
오브젝트의 명세는 YAML 파일로 정의한다. **YAML 파일**에 **오브젝트의 종류와 원하는 상태를 입력**한다.

이러한 명세는 생성, 조회, 삭제로 관리할 수 있기 때문에 REST API로 쉽게 노출할 수 있다. 접근 권한 설정도 같은 개념을 적용하여 누가 어떤 오브젝트에 어떤 요청을 할 수 있는지 정의할 수 있다.

```yaml
apiVersion: v1
kind: Pod
metadata:
    name: example
spec:
    containers:
    - name: busybox
      image: busybox:1.25
```
##### 요구되는 필드
> [스펙 상세 설명](https://blog.voidmainvoid.net/138)

- apiVersion: 스크립트를 실행하기 위한 **쿠버네티스 API 버전**
- kind: 어떤 종류의 오브젝트를 생성하고자 하는 지
- metadata
  - name: 오브젝트를 유일하게 구분지어 줄 데이터. 이름, UID 그리고 선택적인 네임스페이스를 포함.
- spec

#### 쿠버네티스 배포방식
쿠버네티스는 애플리케이션을 배포하기 위해 **원하는 상태**를 다양한 오브젝트에 라벨을 붙여 정의(YAML)하고 API 서버에 전달하는 방식을 사용한다.

### 쿠버네티스 아키텍처
쿠버네티스는 중앙(Master)에 API 서버와 상태 저장소를 두고 각 서버(Node)의 에이전트(Kubelet)와 통신하는 단순한 구조이다.

#### 마스터-노드 구조
쿠버네티스는 전체 클러스터를 관리하는 마스터와 컨테이너가 배포되는 노드로 구성된다. 모든 명령은 마스터의 API 서버를 호출하고 노드는 마스터와 통신하면서 필요한 작업을 수행한다. 특정 노드의 컨테이너에 명령하거나 로그를 조회할 때도 노드에 직접 명령하는 게 아니라 마스터에 명령을 내리고 마스터가 노드에 접속하여 대신 결과를 응답한다.

